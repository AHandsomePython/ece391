#ifndef ATA_H
#define ATA_H

#include "../lib.h"

#define ATA1_IRQ 13
#define ATA2_IRQ 14 


// primary one 
#define ATA1_DATA0  0x1F0    ///R/W data
#define ATA1_DATA1  0x1F1    /// R error, W feature
#define ATA1_DATA2  0x1F2    /// R/W count sector
#define ATA1_DATA3  0x1F3    /// R/W sactor number --- CHS/LNA28/LBA48, LBAlo
#define ATA1_DATA4  0x1F4    /// LBAmid
#define ATA1_DATA5  0x1F5    /// LBAhi
#define ATA1_DATA6  0x1F6    /// Drive/head
#define ATA1_DATA7  0x1F7    /// R status, W cmd

#define ATA1_CMD0 0x3F6      /// R alternate status, W device control
#define ATA1_CMD1 0x3F7      /// R drive address


// secondary one 
#define ATA2_DATA0  0x170    ///R/W data
#define ATA2_DATA1  0x171    /// R error, W feature
#define ATA2_DATA2  0x172    /// R/W count sector
#define ATA2_DATA3  0x173    /// R/W sactor number --- CHS/LNA28/LBA48, LBAlo
#define ATA2_DATA4  0x174    /// LBAmid
#define ATA2_DATA5  0x175    /// LBAhi
#define ATA2_DATA6  0x176    /// Drive/head
#define ATA2_DATA7  0x177    /// R status, W cmd

#define ATA2_CMD0 0x376      /// R alternate status, W device control
#define ATA2_CMD1 0x377      /// R drive address


// command
#define ID_CMD 0xEC
#define RESSET_CMD 0x04
#define READ_SECTOR_CMD 0x20
#define WRITE_SECTOR_CMD 0x30
#define CA_FLUSH 0xE7



typedef struct ata_dev{
    int master_f;  // master flag, it's 0 when it's salve, it's 1 when it's master
    uint32_t lba28;  // contain the total number of 28 bit LBA addressable sectors on the drive
    uint32_t lba48l;  // contain the total number of 48 bit LBA addressable sectors on the drive
    uint32_t lba48h;
    uint32_t par_length; // total partition length (sectors)
    uint32_t stdlba;
}ata_dev_t;



int ata1_handler(unsigned int ignore);
int ata2_handler(unsigned int ignore);
int ata_indentify(ata_dev_t* ata);
void ata_reset(ata_dev_t* ata);
void ata_delay(ata_dev_t* ata);
int read_ata_st(int sector, uint8_t* buf, ata_dev_t* ata, int lba);
int pio28_read(int sector, uint8_t* buf, ata_dev_t* ata, int abs_lba);
int pio28_write(int sector, uint8_t* buf, ata_dev_t* ata, int abs_lba);
int pio48_read();
void ata_init();
void ata_test();

int write_ata_st(int sector, uint8_t* buf, ata_dev_t* ata, int lba);
int read_ata_st(int sector, uint8_t* buf, ata_dev_t* ata, int lba);
inline ata_dev_t* get_ata_device();

/*


Offset from
"I/O" base

Direction	Function	Description	Param. size LBA28/LBA48
0	R/W	Data Register	Read/Write PIO data bytes	16-bit / 16-bit
1	R	Error Register	Used to retrieve any error generated by the last ATA command executed.	8-bit / 16-bit
1	W	Features Register	Used to control command specific interface features.	8-bit / 16-bit
2	R/W	Sector Count Register	Number of sectors to read/write (0 is a special value).	8-bit / 16-bit
3	R/W	Sector Number Register (LBAlo)	This is CHS / LBA28 / LBA48 specific.	8-bit / 16-bit
4	R/W	Cylinder Low Register / (LBAmid)	Partial Disk Sector address.	8-bit / 16-bit
5	R/W	Cylinder High Register / (LBAhi)	Partial Disk Sector address.	8-bit / 16-bit
6	R/W	Drive / Head Register	Used to select a drive and/or head. Supports extra address/flag bits.	8-bit / 8-bit
7	R	Status Register	Used to read the current status.	8-bit / 8-bit
7	W	Command Register	Used to send ATA commands to the device.	8-bit / 8-bit





Offset from
"Control" base

Direction	Function	Description	Param. size LBA28/LBA48
0	R	Alternate Status Register	A duplicate of the Status Register which does not affect interrupts.	8-bit / 8-bit
0	W	Device Control Register	Used to reset the bus or enable/disable interrupts.	8-bit / 8-bit
1	R	Drive Address Register	Provides drive select and head select information.	8-bit / 8-bit




Error Register
Bit	Abbreviation	Function
0	AMNF	Address mark not found.
1	TKZNF	Track zero not found.
2	ABRT	Aborted command.
3	MCR	Media change request.
4	IDNF	ID not found.
5	MC	Media changed.
6	UNC	Uncorrectable data error.
7	BBK	Bad Block detected.



Drive / Head Register (I/O base + 6)
Bit	Abbreviation	Function
0 - 3		In CHS addressing, bits 0 to 3 of the head. In LBA addressing, bits 24 to 27 of the block number.
4	DRV	Selects the drive number.
5	1	Always set.
6	LBA	Uses CHS addressing if clear or LBA addressing if set.
7	1	Always set.



Status Register (I/O base + 7)
Bit	Abbreviation	Function
0	ERR	Indicates an error occurred. Send a new command to clear it (or nuke it with a Software Reset).
1	IDX	Index. Always set to zero.
2	CORR	Corrected data. Always set to zero.
3	DRQ	Set when the drive has PIO data to transfer, or is ready to accept PIO data.
4	SRV	Overlapped Mode Service Request.
5	DF	Drive Fault Error (does not set ERR).
6	RDY	Bit is clear when drive is spun down, or after an error. Set otherwise.
7	BSY	Indicates the drive is preparing to send/receive data (wait for it to clear). 
    In case of 'hang' (it never clears), do a software reset.

*/
#endif
